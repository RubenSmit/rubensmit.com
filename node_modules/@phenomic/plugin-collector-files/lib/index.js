"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

exports.getId = getId;
exports.formatDate = formatDate;
exports.getFieldValue = getFieldValue;
exports.injectData = injectData;
exports.parsePath = parsePath;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require("debug")("phenomic:plugin:collector-files");

var sep = "/";
function normalizeWindowsPath(value) {
  return value.replace(/(\/|\\)+/g, sep);
}

function getId(name, json) {
  var extensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (json.data.path) {
    debug("id for '" + name + "' is '" + json.data.path + "' (from json)");
    return json.data.path;
  }
  // normalize windows path
  name = normalizeWindowsPath(name);
  // remove (index).md,json etc, for id
  var id = name
  // @todo remove from supportedFileTypes!
  // remove extension for prettier keys
  .replace(new RegExp("\\.(" + extensions.join("|") + ")$"), "")
  // remove index too (and consider README as index)
  .replace(/\/(index|README)$/, "");
  debug("id for '" + name + "' is '" + id + "' (automatically computed)");
  return id;
}

function formatDate(dateString) {
  var date = new Date(dateString).toISOString();
  return date.substring(0, date.indexOf("T"));
}

function isLiteral(value) {
  var type = typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value);
  return type === "string" || type === "number" || type === "boolean";
}

function isArrayOfLiterals(array) {
  return Array.isArray(array) && array.every(isLiteral);
}

function getFieldValue(json, id) {
  if (isArrayOfLiterals(json.data[id])) {
    return json.data[id];
  }
  if (isLiteral(json.data[id])) {
    return [json.data[id]];
  }
  return [];
}

var dateLength = "YYYY-MM-DD".length;
function injectData(name, json) {
  var injectedData = {
    filename: name
  };
  try {
    injectedData.date = formatDate(name.slice(0, dateLength));
  } catch (e) {
    // assuming date is not valid
  }
  return {
    data: (0, _extends3.default)({}, injectedData, json.data),
    partial: (0, _extends3.default)({}, injectedData, json.partial)
  };
}

function parsePath(name) {
  var pathSegments = name.split(sep);
  var allPaths = pathSegments.reduce(function (acc, v) {
    acc.push(acc.length > 0 ? acc[acc.length - 1] + sep + v : v);
    return acc;
  }, []);
  var filename = pathSegments[pathSegments.length - 1];
  return { filename: filename, allPaths: allPaths };
}

var collectorFiles = function collectorFiles() {
  return {
    name: "@phenomic/plugin-collector-files",
    collectFile: function collectFile(_ref) {
      var db = _ref.db,
          name = _ref.fileName,
          json = _ref.parsed,
          transformer = _ref.transformer;

      name = normalizeWindowsPath(name);
      var id = getId(name, json, transformer.supportedFileTypes);

      var _parsePath = parsePath(name),
          filename = _parsePath.filename,
          allPaths = _parsePath.allPaths;

      var adjustedJSON = injectData(filename, json);
      // debug(`collecting '${filename}'`, adjustedJSON);
      debug("collecting '" + filename + "'");
      // full resource, not sorted
      db.put(null, id, adjustedJSON);
      return allPaths.map(function (pathName) {
        var relativeKey = id.replace(pathName + sep, "");
        if (relativeKey === pathName) {
          relativeKey = "";
        }
        debug("collecting '" + relativeKey + "' for path '" + pathName + "'");
        // @todo optimize this and avoid inserting adjustedJSON several times
        // we should be able to inject a ref to get it back from __null__ when
        // reading
        db.put([pathName], relativeKey, adjustedJSON);
        db.put([pathName, "default"], relativeKey);
        (0, _keys2.default)(json.data).map(function (type) {
          return getFieldValue(json, type).map(function (fieldValue) {
            debug("collecting '" + relativeKey + "' for path '" + pathName + "': " + type + "/" + fieldValue);
            db.update([pathName, type, fieldValue], relativeKey);
            db.update([type, "default"], fieldValue);
            db.update([type, "path", pathName], fieldValue);
          });
        });
      });
    }
  };
};

exports.default = collectorFiles;