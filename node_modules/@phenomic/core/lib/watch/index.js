"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.oneShot = oneShot;

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _sane = require("sane");

var _sane2 = _interopRequireDefault(_sane);

var _globby = require("globby");

var _globby2 = _interopRequireDefault(_globby);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var execSync = require("child_process").execSync;

var canUseWatchman = function () {
  try {
    execSync("watchman --version", { stdio: ["ignore"] });
    return true;
  } catch (e) {
    return false;
  }
}();

var debug = require("debug")("phenomic:core:watch");

var toFile = function toFile(root, filepath) {
  return {
    name: filepath,
    fullpath: _path2.default.join(root, filepath)
  };
};

function glob(path, patterns) {
  return _globby2.default.sync(patterns, { cwd: path }).map(function (file) {
    return toFile(path, file);
  });
}

function oneShot(options) {
  return glob(options.path, options.patterns);
}

function createWatcher(options) {
  debug("path:", options.path);
  debug("extensions:", options.patterns);
  var watcher = (0, _sane2.default)(options.path, {
    watchman: canUseWatchman,
    glob: options.patterns
  });
  var subscribers = [];
  var ready = false;
  var closeMe = false;
  /* eslint-disable flowtype/no-mutable-array */
  var files = _globby2.default.sync(options.patterns, { cwd: options.path }).map(function (file) {
    return toFile(options.path, file);
  });
  debug("files", files.map(function (file) {
    return file.name;
  }));

  watcher.on("ready", function () {
    debug("watcher: ready");
    ready = true;
    if (closeMe) {
      debug("watcher: will close");
      // close but not like NOW because leveldb might crash (no idea why)
      setTimeout(function () {
        debug("watcher: closed after being ready");
        watcher.close();
      }, 1000);
    }
  });
  watcher.on("change", function (filepath, root, stat) {
    debug("watcher: file changed", filepath, root, stat);
    subscribers.forEach(function (func) {
      return func(files);
    });
  });
  watcher.on("add", function (filepath, root, stat) {
    debug("watcher: file added", filepath, root, stat);
    files.push(toFile(options.path, filepath));
    subscribers.forEach(function (func) {
      return func(files);
    });
  });
  watcher.on("delete", function (filepath, root) {
    debug("watcher: file deleted", filepath, root);
    var index = files.find(function (file) {
      return file && file.name === filepath;
    });
    if (index) {
      delete files[files.indexOf(index)];
    }
    subscribers.forEach(function (func) {
      return func(files);
    });
  });

  return {
    onChange: function onChange(func) {
      debug("watcher#onChange");
      func(files);
      subscribers = [].concat((0, _toConsumableArray3.default)(subscribers), [func]);
      return function unsubscribe() {
        return subscribers = subscribers.filter(function (item) {
          return item !== func;
        });
      };
    },
    close: function close() {
      debug("watcher#closed");
      subscribers = [];
      // sane can be "slow" to say "I am ready"
      // and during static build, we close the watcher directly
      // we should probably not use a watcher for static build
      // but I am lazy and will refactor later
      if (!ready) {
        debug("watcher: will close after being ready");
        closeMe = true;
        return;
      }
      watcher.close();
    }
  };
}

exports.default = createWatcher;