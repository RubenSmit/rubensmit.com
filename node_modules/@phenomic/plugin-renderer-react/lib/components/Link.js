"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isActive = exports.handleKeyDown = exports.handleClick = exports.handleEvent = undefined;

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require("babel-runtime/helpers/objectWithoutProperties");

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require("react");

var React = _interopRequireWildcard(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

var _LinkHash = require("./Link.hash.js");

var _LinkHash2 = _interopRequireDefault(_LinkHash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BASENAME = process.env.PHENOMIC_APP_BASENAME || "/";

var origin = function origin(url) {
  return (
    // jsdom can return "null" string...
    url.origin !== "null" && url.origin ||
    // // IE does not correctly handle origin, maybe Edge does...
    url.protocol + "//" + url.hostname + (url.port ? ":" + url.port : "")
  );
};

var isSameOrigin = function isSameOrigin(url) {
  return origin(url) === origin(window.location) && url.pathname.indexOf(BASENAME) > -1;
};

var shouldIgnoreEvent = function shouldIgnoreEvent(event
// If target prop is set (e.g. to "_blank"), let browser handle link.
) {
  return event.currentTarget && event.currentTarget.target || event.defaultPrevented ||
  // $FlowFixMe modifier pressed
  event.metaKey || event.altKey || event.ctrlKey || event.shiftKey || false;
};

var goToUrl = function goToUrl(event, router) {
  if (event.currentTarget && isSameOrigin(event.currentTarget)) {
    event.preventDefault();
    // extract to get only interesting parts
    var _event$currentTarget = event.currentTarget,
        pathname = _event$currentTarget.pathname,
        search = _event$currentTarget.search,
        hash = _event$currentTarget.hash;

    var route = {
      // ensure we don't provide the basename (if defined in rr config)
      // but ensure we provide a / as the first char
      // ( to avoid rr weird bug where page is ok, but url is drunk)
      pathname: pathname.replace(BASENAME.slice(0, -1), ""),
      search: search,
      hash: hash
    };
    // react-router v3
    if (router.push) router.push(route);else if (router.history && router.history.push)
      // react-router v4
      // $FlowFixMe well it's hard to support 2 APIs ?
      router.history.push(route);

    // react-router doesn't handle the scroll
    // so we scroll to top or move to the hash
    if (!hash) window.scrollTo(0, 0);else (0, _LinkHash2.default)(hash);
  }
};

var handleEvent = exports.handleEvent = function handleEvent(props, router, test) {
  return function (event) {
    if (props && props.onPress) props.onPress(event);
    if (props && props.onClick) props.onClick(event);
    if (!shouldIgnoreEvent(event) && (test ? test(event, props) : true)) goToUrl(event, router);
  };
};

var handleClick = exports.handleClick = function handleClick(props, router) {
  return handleEvent(props, router,
  // $FlowFixMe left click
  function (event) {
    return event.button === 0;
  });
};

var handleKeyDown = exports.handleKeyDown = function handleKeyDown(props, router) {
  return handleEvent(props, router,
  // $FlowFixMe  enter key
  function (event) {
    return event.keyCode === 13;
  });
};

var isActive = exports.isActive = function isActive(url, _ref) {
  var router = _ref.router;

  var urlObj = { pathname: url };
  // trick to normalize url when possible, by the browser
  // (eg: relative links are "resolved")
  if (typeof document !== "undefined") {
    var link = document.createElement("a");
    link.href = url;
    if (isSameOrigin(link)) {
      urlObj = { pathname: link.pathname };
      // now 'urlObj' is absolute
    }
  }

  return router && router.isActive && router.isActive(urlObj);
};

function Link(props, context) {
  var to = props.to,
      style = props.style,
      activeStyle = props.activeStyle,
      className = props.className,
      activeClassName = props.activeClassName,
      otherProps = (0, _objectWithoutProperties3.default)(props, ["to", "style", "activeStyle", "className", "activeClassName"]);

  var href = to || props.href || "";

  var isUrlActive = isActive(href, context);
  var computedClassName = (0, _classnames2.default)(className, isUrlActive && activeClassName);
  var computedStyle = (0, _extends3.default)({}, style, isUrlActive ? activeStyle : {});

  return React.createElement("a", (0, _extends3.default)({}, otherProps, {
    href: href.indexOf("://") > -1 ? href : href.charAt(0) === "/" ? BASENAME + href.slice(1) : href,
    onClick: handleClick(props, context.router),
    onKeyDown: handleKeyDown(props, context.router)
    // weird syntax to avoid undefined/empty object/strings
    // for now, it's falling back to normal links
  }, (0, _keys2.default)(computedStyle).length ? { style: computedStyle } : {}, computedClassName ? { className: computedClassName } : {}));
}

Link.contextTypes = {
  router: _propTypes2.default.object.isRequired
};

Link.displayName = "Link";

exports.default = Link;